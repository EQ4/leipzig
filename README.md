[Leipzig](https://github.com/ctford/leipzig)
============================================

[![Build Status](https://travis-ci.org/ctford/leipzig.png)](https://travis-ci.org/ctford/leipzig)

A composition library for [Overtone](https://github.com/overtone/overtone) by [@ctford](https://github.com/ctford).

Examples
--------
See [Row, row, row your boat](src/leipzig/example/row_row_row_your_boat.clj) or
[whelmed](https://github.com/ctford/whelmed) for examples.

In [Leipzig from scratch](https://www.youtube.com/watch?v=Lp_kQh34EWA), I demonstrate how to create a piece from
`lein new` onwards.

Leipzig came out of a talk I gave called
[Functional Composition](http://www.infoq.com/presentations/music-functional-language), where I explain basic music
theory using Overtone and Clojure.

Use
---
Include it as a dependency in your project.clj, along with Overtone:

    [overtone "0.9.1"]
    [leipzig "0.8.0"]

API
---

[API documentation](http://ctford.github.io/leipzig/), generated by [Codox](https://github.com/weavejester/codox).

Building a melody
-----------------

Leipzig models music as a sequence of notes, each of which is a map:

    {:time 2000
     :pitch 67
     :duration 1000
     :part :melody}

You can create a melody with the `phrase` function. Here's a simple melody:

    (use 'leipzig.melody)

    (def melody
      (phrase [2 2 1 1 2]
              [2 0 2 3 4]))

The first argument to `phrase` is a sequence of durations. The second is a sequence of pitches. `phrase` builds a sequence of notes which we can transform with sequence functions, either from Leipzig or ones from Clojure's core libraries.

To play a melody, first define an arrangement. `play-note` is a multimethod that dispatches on the `:part` key of each note, so you can easily define an instrument responsible for playing notes of each part. Then, put the sequence of notes into a particular key and tempo and pass them along to `play`:

    (require ['overtone.live :as 'overtone])
    (use 'leipzig.live
         'leipzig.scale)

    (overtone/definst chime [freq 440 tremelo 0.05]
      (* (overtone/sin-osc freq)
         (overtone/env-gen (overtone/perc) :action overtone/FREE)
         (overtone/sin-osc tremelo 1.6)))

    (defmethod play-note :default [{freq :pitch}] (chime (overtone/midi->hz freq)))

    (->>
      melody
      (where :time (bpm 90))
      (where :duration (bpm 90))
      (where :pitch (comp C major))
      play)

There's nothing magic about `where`. It just applies a function to a particular key of each note, like `update-in` for sequences.

Actually, `phrase` accepts more than just pitches. `nil`s are interpreted as rests and maps as chords. Here's a more advanced example that plays a 1/4/5 chord progression on the offbeat. We'll add a bit of colour to how we play the chords by introducing some tremelo when we invoke `chime`.

NB: We need the `when` in `play-note` so that we don't crash when we encounter a rest, which have `:pitch` of `nil`.

    (use 'leipzig.chord)

    (defmethod play-note :chords [{freq :pitch}] (when freq (chime (overtone/midi->hz freq) 2)))

    (def accompaniment
      (->>
        (phrase (repeat 1)
                [nil triad nil triad nil (-> triad (root 3)) nil (-> triad (root 4))])
        (with (phrase (repeat 2) [0 0 3 4]))
        (wherever :pitch, :pitch lower)
        (where :part (is :chords))))

You can then put multiple series of notes together:

    (->>
      accompaniment
      (then (with accompaniment melody))
      (then (with accompaniment (->> melody drop-last (then (phrase [1 1 4] [4 6 7])))))
      (where :time (bpm 90))
      (where :duration (bpm 90))
      (wherever :pitch, :pitch (comp C major))
      play)

Design
------

Leipzig is designed to play nicely with Clojure's standard sequence functions. Therefore, Leipzig's functions for transforming notes all take the sequence as a final argument so that they can be threaded with the `->>` macro:

    (->>
      (phrase (repeat 1) (cycle [0 2 4]))
      (take 24)
      (filter #(-> % :time even?)))

These sequence functions all exhibit "closure" i.e. their result is the same shape as their input. That allows them to be used and combined very flexibly. `where` for example, can raise the pitch, set the part or put the notes into a particular tempo:

    (->> notes (where :pitch inc))
    (->> notes (where :part (is :melody)))
    (->> notes (where :time (bpm 90)))

Leipzig aims to be a library rather than a framework or environment. It uses simple Clojure datastructures and strives to be as open as possible. A new timing scheme, tuning or tempo can be mixed with Leipzig's other functions just as easily as the ones that come with the library.

Testing
-------

To run the unit tests without having to start Overtone's Supercollider server:

    lein midje leipzig.test.*
